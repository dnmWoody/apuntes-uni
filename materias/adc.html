<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADC - Arquitectura de Computadoras</title>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <link rel="stylesheet" href="styleM.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <h2>Contenido</h2>
            <ul>
                <li><a href="#interrupciones" onclick="hideMenu()">Interrupciones</a></li>
                <li><a href="#microcontroladores" onclick="hideMenu()">Microcontroladores</a></li>
                <li><a href="#pipeline" onclick="hideMenu()">Pipeline</a></li>
                <li><a href="#entrada-salida" onclick="hideMenu()">Entrada - Salida</a></li>
                <li><a href="#paralelismo" onclick="hideMenu()">Paralelismo</a></li>
                <li><a href="#secuenciadores" onclick="hideMenu()">Secuenciadores</a></li>
                <li><a href="#memoria-cache" onclick="hideMenu()">Memoria Caché</a></li>
                <li><a href="#coherencia-cache" onclick="hideMenu()">Coherencia Caché</a></li>
                <li><a href="#examenes" onclick="hideMenu()">Exámenes</a></li>
                <li><a href="../index.html" onclick="hideMenu()" style="color: rgb(207, 89, 89);">← Volver atrás</a></li>
            </ul>
            <button class="theme-toggle" onclick="toggleTheme()">Cambiar Tema</button>
        </aside>

        <!-- Botón para mostrar el menú cuando esté oculto en modo responsive -->
        <button id="show-menu-btn" class="show-menu-btn" onclick="toggleMenu()">Menú</button>
        <!--<button id="show-atras-btn" class="show-atras-btn"><a href="../index.html">Volver atrás</a></button>-->


        <main class="main-content" id="main-content">
            <!-- ********************************************************************************************************** INTERRUPCIONES -->
            <section id="interrupciones" class="contenido">
                <h2 class="titulo2">Interrupciones</h2>
                <p>Las interrupciones son cambios en el flujo de control causados no por el programa en ejecución, sino por eventos externos al mismo, como los relacionados con operaciones de E/S (Entrada/Salida).<br>
                    Por ejemplo, un disco duro que realiza una transferencia puede interrumpir el flujo normal de trabajo cuando finaliza la operación. Otro ejemplo es el teclado: al presionar una tecla, se genera una interrupción.<br>
                    Cuando se habla de interrupciones, se hace referencia a la detención temporal del flujo normal de ejecución del procesador, transfiriendo el control a la unidad manejadora de interrupciones, que se encargará de realizar la acción apropiada.<br>
                    Una vez finalizada la acción, el control debe ser devuelto al proceso interrumpido, restaurando los registros y el estado interno del sistema tal como estaban antes de la interrupción.<br>
                    Las interrupciones son asíncronas, lo que significa que pueden ocurrir en cualquier momento, ya que no son controladas directamente por el programa en ejecución.
                </p>
                <br>

                <h3>Mecanismo de interrupciones (Paso a Paso)</h3>
                <ol>
                    <li><b>El dispositivo genera una interrupción:</b> 
                        <br>Un dispositivo, como el teclado o un disco duro, necesita atención de la CPU, por lo que envía una señal de interrupción a través del bus del sistema, que es la conexión física entre los componentes de la computadora.</li>
                    <li><b>La CPU está lista para manejar la interrupción:</b>
                        <br> La CPU sigue trabajando en sus tareas hasta que pueda atender la interrupción. Una vez que esté lista, envía una señal de reconocimiento para decirle al dispositivo que la interrupción ha sido registrada.</li>
                    <li><b>Identificación del dispositivo que generó la interrupción:</b>
                        <br>El dispositivo coloca un número, llamado <b>vector de interrupción</b>, en el bus de datos. Este número identifica qué dispositivo solicitó la interrupción.</li>
                    <li><b>La CPU toma el vector de interrupción: </b>
                        <br> La CPU guarda temporalmente ese número (el vector de interrupción), que servirá para localizar la rutina que debe ejecutarse para manejar la interrupción.</li>
                    <li><b>La CPU guarda su estado actual: </b> 
                        <br> La CPU necesita recordar en qué punto estaba ejecutando el programa cuando ocurrió la interrupción. Para ello, guarda el <b>contador de programa</b> (que le dice qué instrucción estaba ejecutando) y el <b>estado del programa</b> (valores de los registros y otros datos importantes) en la pila, una zona de la memoria.</li>
                    <li><b>La CPU localiza la rutina de manejo de interrupciones: </b>
                        <br>Usando el vector de interrupción, la CPU busca una tabla especial en la memoria (ubicada en la parte baja de la memoria) que le indica dónde está la <b>rutina de servicio de interrupción</b>, que es el código que se va a ejecutar para manejar la interrupción.</li>
                    <li><b>Guardado de registros: </b>
                        <br>La rutina de servicio de interrupción guarda todos los registros (información importante que estaba usando la CPU), para poder restaurarlos después de atender la interrupción. Estos se guardan en la pila o en una tabla del sistema.</li>
                    <li><b>Identificación específica del dispositivo: </b>
                        <br>A veces, varios dispositivos pueden compartir el mismo vector de interrupción. En este caso, la CPU debe leer un registro en el dispositivo para saber cuál de ellos exactamente generó la interrupción (por ejemplo, si fue el teclado o un ratón).</li>
                    <li><b> Lectura de la información sobre la interrupción: </b>
                        <br>La CPU recoge toda la información adicional que necesita sobre el evento que causó la interrupción, como códigos de error o datos específicos del dispositivo.</li>
                    <li><b>Manejo de errores de E/S: </b>
                        <br>Si hubo algún error durante la operación de entrada/salida (E/S), como un problema al leer del disco duro, la rutina de servicio se encarga de solucionarlo aquí.</li>
                    <li><b>Actualización de variables: </b>
                        <br>Si la interrupción requiere que se actualicen contadores o variables globales, como el número de datos procesados, esto se hace en este paso.</li>
                    <li><b>Notificación al dispositivo: </b>
                        <br>Una vez procesada la interrupción, la CPU puede enviar un código al dispositivo para indicarle que la interrupción ha sido manejada correctamente.</li>
                    <li><b>Restauración del estado previo: </b>
                        <br>Se restauran los registros que fueron guardados para que la CPU vuelva exactamente al estado en el que estaba antes de la interrupción.</li>
                    <li><b>Reaundación del trabajo: </b>
                        <br>Finalmente, la CPU ejecuta una instrucción especial que la devuelve al estado anterior y continúa ejecutando el programa desde donde fue interrumpido.</li>
                </ol>
                
                <p>
                    Este proceso ocurre muy rápido, casi de manera instantánea, y por eso se puede, por ejemplo escribir en un teclado, seguir escribiendo sin notar ningún retraso. 
                </p>
                <br>

                <h3>Interrupciones Anidadas</h3>
                <p>
                    Las interrupciones anidadas permite que una interrupción de baja prioridad sea interrumpida por otra de alta prioridad, creando así una pila de interrupciones donde cada nivel se guarde su propio estado.<br>
                    Este mecanismo permite que los eventos más críticos puedan ser atendidos de inmediato. <br>
                    Cuando una ocurre la interrupción durante el manejo de otra interrupción, el estado de la CPU (registros, contador de programa y la palabra del estado del programa), se guarda en una estructura de pila. Esta pila sigue el principio de LIFO (Last In, First Out), lo que significa que la ultima interrupción en ser atendida es la primera en ser completada.
                </p>
                <br>

                <h3>Interrupciones Secuenciales</h3>
                <p>
                    Las interrupciones secuenciales se basa en manejar una interrupción a la vez antes de atender la siguiente, completando la ISR (Interrupt Service Routine).<br>
                    Aunque este método es simple, puede existir ciertas desventajas ya que existen interrupciones de diferentes prioridades. <br>
                    En estos casos, el sistema debe esperar que se complete la interrupción actual antes de antender la siguiente, lo que puede resultar demoras significativas si una interrupción de alto prioridad ocurre mientras se está manejando una interrupción de baja prioridad.<br>
                    Esto puede generar efectos negativos en la capacidad de respuesta del sistema y su desempeño general, especialmente en aplicaciones de tiempo real donde la rapidez es crítica.
                </p>
                <br>

                <h2>Ampliación de conceptos: Prioridades, Rutinas de Servicio (ISR), su ubicación y acceso a ellas</h2>
                <h3>Prioridades</h3>
                <p>
                    En un sistema de interrupciones, es crucial tener un mecnaismo para poder priorizar y manejar interrupciones mas urgentes. Existen varias alternativas para la gestión de interrupciones: 
                    <ul class="lista">
                        <li> <b>Interrupciones anidadas:</b> Permiten que una interrupción sea interrumpida por otra de mayor gravedad. Esto se logra guardadno el estado de la interrupción actual y atendiendo primero la interrupción más crítica. Este método asegura que las interrupciones más urfentes sean tratadas inmediatamente, mejorando la capacidad de respuesta del sistema.</li>
                        <li> <b>Inhabilitación de interrupciones:</b> Consiste en deshablitar todas las interrupciones mientras se está atendiendo una. Este enfoque simplifica el manejo de interrupciones, pero resulta ineficiente en sistemas donde las interrupciones mas críticas deben ser atendidas sin demora.</li>
                    </ul>
                    <br>
                    
                    <i>Tener interrupciones manejadas por prioridad es más efectivo y logra un sistema mas equilibrado mejorando así el rendimiento del sistema en aplicaciones de tiempo real.</i>
                </p>
                <br>

                <h3>Rutinas de Servicio de Interrupciones (ISR)</h4>
                <p>
                    Las <b>ISR (Interrupt Service Routines)</b> son programas especiales que se ejecutan automáticamente para <i>atender eventos específicos</i> llamados <b>interrupciones</b>. El objetivo principal de cada ISR es <i>gestionar el evento que causó la interrupción y restaurar el sistema</i> para que continúe funcionando normalmente. 
                    <div class="cuadro">
                        <b>Ejemplo Claro de ISR:</b><br>
                        Imagina que estás viendo una película en tu computadora y recibes un mensaje en WhatsApp.<br>
                        La interrupción es el mensaje entrante. El sistema operativo pausa la película momentáneamente, abre WhatsApp para mostrarte la notificación, y luego retoma la película donde se quedó.
                    </div>
                    <br>
                    
                    <ul class="lista">
                        <li>
                            <b>Ubicación de la ISR:</b> Las direcciones de las ISR se encuentran en una estructura conocida como vector de interrupciones que es una tabla en memoria. Cada entrada de la tabla contiene la dirección de inicio de una ISR específica.
                            <div class="cuadro">
                                Si presionas una tecla en tu teclado, la CPU consulta el vector de interrupciones para encontrar la dirección exacta de la ISR que maneja las pulsaciones. Luego, esa ISR registra la tecla que presionaste y permite que sigas usando la computadora sin problemas.
                            </div>
                        </li>
                        <br>
                        
                        <li>
                            <b>Acceso a las ISR:</b> Cuando ocurre la interrupción, el procesador consulta el vector de interrupciones utilizando el número de interrupción para obtener la dirección de la ISR correspondiente. Este número de interrupción actúa como un índice en la tabla del vector. EL procesador luego transfiere el control a la ISR para manejar la interrupción.
                        </li>
                        <br>
                        
                        <i>
                            El diseño eficiente y la correcta ubicación de las ISR son cruciales para el manejo efectivo de las interrupciones. <br> 
                            Al tener una tabla centralizada, el sistema puede acceder de forma rápida a la ISR necesaria, garantizando así la respuesta rápida al evento.   
                        </i>
                    </ul>
                </p>
                <br>
                
                <h3>Beneficios de la Prioridad en Interrupciones y ISR</h3>
                <ul class="lista">
                    <li><b>Mejora de la Respuesta del Sistema:</b> Las interrupciones más urgentes se manejan primero, garantizando que eventos críticos, como alarmas, reciban atención inmediata.</li>
                    <li><b>Optimización de Recursos:</b> La CPU no pierde tiempo en tareas menos importantes si hay eventos prioritarios que atender.</li> <li><b>Mantenimiento de la Integridad del Sistema:</b> Al procesar interrupciones en el orden adecuado, se evita que el sistema falle o se vuelva inestable.</li> <li><b>Flexibilidad en el Manejo de Interrupciones:</b> La prioridad permite adaptar el comportamiento del sistema según las necesidades del momento, garantizando que siempre se atiendan las tareas críticas a tiempo.</li> 
                </ul>
                <br>
                
                <h3>Técnicas para Determinar el Dispositivo que provocó la interrupción</h3>
                <ul class="lista">
                    <li><b>Múltiples lineas de Interrupciones:</b> Cada dispositivo tiene su propia línea de interrupción hacia el procesador, permitiendo identificar rápidamente el origen del evento.</li>
                    <li><b>Consulta de software (polling):</b> La CPU revisa constantemente cada dispositivo para verificar si ocurrió una interrupción, aunque esto consume más tiempo y recursos.</li>
                    <li><b>Consulta de hardware:</b> Se emplea un controlador de interrupciones que consulta automáticamente qué dispositivo generó la señal y notifica al procesador.</li>
                    <li><b>Arbitraje de Bus:</b> Los dispositivos compiten por el control del bus; un mecanismo de prioridad decide cuál tiene permiso para enviar la interrupción primero.</li>
                </ul>
                <br>
                
                <h3>Propiedades de las Interrupciones</h3>
                <ul class="lista">
                    <li><b>Asincronía:</b> Las interrupciones pueden ocurrir en cualquier momento, ya que no dependen del flujo del programa en ejecución.</li>
                    <li><b>Prioridad:</b> Las interrupciones tienen diferentes niveles de prioridad para garantizar que los eventos más críticos se atiendan primero.</li>
                    <li><b>Anidamiento:</b> Una interrupción puede ser interrumpida por otra de mayor prioridad, lo que permite una gestión eficiente de eventos urgentes.</li>
                    <li><b>Restauración del estado:</b> La CPU guarda y recupera el estado del programa interrumpido para continuar la ejecución sin pérdida de datos.</li>
                    <li><b>Eficiencia:</b> Las interrupciones permiten que la CPU no desperdicie tiempo verificando constantemente los dispositivos; sólo actúa cuando es necesario.</li>
                    <li><b>Manejo de errores:</b> Las interrupciones permiten detectar y gestionar errores en operaciones de E/S o hardware, mejorando la robustez del sistema.</li>
                </ul>
                
                <button onclick="scrollToTop('interrupciones')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** MICROCONTROLADORES -->
            <section id="microcontroladores" class="contenido">
                <h2 class="titulo2">MICROCONTROLADORES</h2>
                <h3>Microcontroladores</h3>
                <p>
                    Un <b>microcontrolador</b> es un circuito integrado programable que ejecuta ordenes grabadas en su memoria.  Es un <b>sistema cerrado</b> que incluye CPU, memoria y periféricos en un solo chip. <br>
                    Está diseñado para <b>aplicaciones específicas</b> y control de aplicaciones. Los microcontroladores son comunes en sistemas embebidos, como electrodomésticos, automóviles, dispositivos médicos y sistemas de automatización industrial.
                </p>
                <div class="contenedor-imagen-tabla">
                    <img src="images/adc-microcontrolador.jpg" width="300px" alt="Microcontrolador" title="Microcontrolador">
                    <img src="images/adc-microprocesador.jpeg" width="300px" alt="Microprocesador" title="Microprocesador">
                </div>
                <br>

                <h3>Microprocesadores</h3>
                <p>
                    Un <b>microprocesador</b> es un circuito integrado que <b>contiene la CPU de una computadora</b>. Es un <b>sistema abierto</b> que requiere <b>componentes</b> externos, como memoria y periféricos para <b>poder funcionar</b>. <br>
                    Los microprocesadores se utilizan en una amplia gama de dispositivos, incluido computadoras personales, servidores, dispositivos móviles y sistemas embebidos de alto rendimiento.
                </p>
                <div class="contenedor-imagen-tabla">
                    <table>
                        <tr>
                            <th style="background-color: rgb(31, 34, 34); ;"> </th>
                            <th>MICRO CONTROLADOR</th>
                            <th>MICRO PROCESADOR</th>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Tipo de sistemas</td>
                            <td>Cerrado</td>
                            <td>Abierto</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Buses</td>
                            <td>Inaccesibles desde el exterior</td>
                            <td>Accesibles desde el exterior</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Memoria</td>
                            <td>Interna, incluye RAM, ROM y almacenamiento</td>
                            <td>Externa, necesita componenetes adicionales</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Flexibilidad</td>
                            <td>Limitada a aplicaciones específicas y tareas predefinidas</td>
                            <td>Alta, se puede utilizar una amplia variedad de aplicaciones</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Complejidad del sistema</td>
                            <td>Menor, integrado en un solo chip</td>
                            <td>Mayor, requiere componentes externos como memoria y periféricos</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Costo</td>
                            <td>Generalmente más barato, todo en un solo chip</td>
                            <td>Generlamente más caro, debido a la necesidad de componentes adicionales</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Ejemplos de uso</td>
                            <td>Electrodomésticos, automóviles, sistemas de automatización</td>
                            <td>Computadoras, servidores, dispositivos móviles</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Capacidad de procesamiento</td>
                            <td>Menos potentes, optimizados para eficiencia y tareas específicas</td>
                            <td>Generalemtne más potentes y rápidos</td>
                        </tr>
                    </table>
                </div>
                <br>

                <h2 class="titulo2">ARQUITECTURAS</h2>
                <div class="contenedor-imagen-tabla">
                    <img src="images/adc-arquitecturas.png" width="800px" alt="arquitecturas" title="Arquitecturas">
                </div>
                <br>
                <h3>Arquitectura Harvard</h3>
                <p>
                    La arquitecura Harvard utiliza <b>dos memorias separadas para instrucciones y datos</b>, permitiendo acceso simultáneo a ambas, lo cual puede incrementar el rendimiento. <br>
                    Esta arquitectura es común en <b>microcontroladores</b>, especialmente en aplicaciones donde se requiere un rendimiento elevado y un control preciso, como en sistemas embebidos y dispositivos de tiempo real. <br><br>
                    En este diseño, la CPU está conectada a dos memorias independientes y con buses diferentes: una para las instrucciones y otra para los datos. Esta configuración permite el <b>paralelismo</b>, ya que se puede acceder a los datos e instrucciones de forma independiente y simultánea.<br>
                    Las memorias no necesariamente deben compartir características, por lo que pueden tener distinta longitud de datos e instrucciones, permitiendo una optimización del uso de la memoria en general.<br>
                    El tiempo de acceso a las instrucciones y a los datos puede superponerse, aumetando la velocidad de procesamiento en cada operación.<br><br>
                    Además, facilita la realización de <b>pipeline</b>, una técnica de segmentación que permite al procesador ejecutar una instrucción mientras busca el código de la siguiente.<br> 
                    Las instrucciones y los datos se almacenan en caches separadas para mejorar el rendimiento. <br>
                    Sin embargo, esta arquitectura tiene <u>desventajas</u>. Divide la cantidad de caché entre instrucciones y datos, lo que solo es beneficioso si la frecuencia de lectura de ambos es similar.<br> 
                    También requiere dos buses separados, lo que aumenta la complejidad y el costo de fabricación.
                </p>
                <br>

                <h3>Arquitectura Von Neumann</h3>
                <p>
                    La arquitectura Von Neumann utiliza una sola memoria para almacenar tanto las instrucciones como los datos.<br>
                    Esta arquitectura describe a la computadora con <b>cuatros secciones principales: </b>
                    <ol>
                        <li>Memoria principal</li>
                        <li>Dispositivos de entrada-salida</li>
                        <li>Unidad Centra de Procesamiento (CPU)</li>
                        <li>Las interconexiones o buses entre todos los bloques funcionales del sistema</li>
                    </ol>
                    <br>

                    Es común en <b>microprocesadores</b> y procesadores de señal digital, debido a su simplicidad y flexibilidad, lo que facilita el diseño en sistemas de propósito general, como los que se encuentran en las computadoras personales. <br><br>
                    En este diseño, la CPU está conectada a una <b>memoria principal única</b> (generalmente RAM), donde se guardan tanto las instrucciones del programa como los datos, lo cual hace que el procesamiento sea eficiente debido a que todo está ubicado en un solo lugar. Esto elimina la necesidad de buses separados y permite una búsqueda más directa y eficiente. <br>
                    Sin embargo, <b>requiere un mecanismo para distinguri entre datos e instrucciones, ya que se almacenan en el mismo formato.</b><br><br>
                    La arquitectura de Von Neumann es relativamente fácil de diseñar y eficiente en el uso de la memoria, ya que no desperdicia espacio de almacenamiento al ser usada por ambos tipos de información. Una particularidad de esta arquitectura es que la <b>conexión se realiza mediante un único bus.</b> El tamaño de las instrucciones es fijado por el ancho del bus; por ejemplo, un microprocesador de 8 bits con un bus de 8 bits tendrá que manejar datos e instrucciones en unidades de 8 bits (bytes). Si se necesita acceder a una instrucción que excede el ancho de bus, se deberán realizar múltiples accesos a la memoria.<br><br>
                    Tener un único bús hace más lenta la respuesta del microprocesador, ya que no puede buscar en memoria una nueva instrucción mientras está transfiriendo datos de la instrucción anterior.<br>
                    Ademas, <b>requiere de dos ciclos de reloj para leer la memoria, uno para las instrucciones y otro para los datos.</b><br>
                    El cuello de botella de Von Neumann se puede mejorar de varias maneras, como con el uso de memoria caché entre la CPU y la memoria princial, o con vías independientes para instrucciones y datos (arquitectura Harvard modificada), para reducir el acceso a memoria.
                </p>
                <br>

                <h2 class="titulo2">INSTRUCCIONES (CISC - RISC)</h2>
                <h3>Conjunto de instrucciones</h3>
                <p>
                    Los <b>microprocesadores</b> suelen ser <b>CISC (Complex Instruction Set Computing)</b>, estos tienen un conjunto de instrucciones grande y complejo, diseñado para realizar tareas complejas en pocas líneas de código. (Secuenciadores microprogramados)
                    <ul class="lista">
                        <li>
                            <b>Características</b>
                            <ul class="lista" style="list-style: circle;">
                                <li><b>Conjunto de instrucciones grandes:</b> Hay muchas instrucciones disponibles, lo que permite realizar tareas complejas en una sola línea de código.</li>
                                <li><b>Complejidad:</b> Hay muchas instrucciones disponibles, lo que permite realizar tareas complejas en una sola línea de código.</li>
                                <li><b>Eficiencia en codificación:</b> Los programadores pueden escribir programas más cortos y complejos, lo que puede reducir el tiempo de desarrollo.</li>
                                <li><b>Variedad de modos de direccionamiento:</b> Permite diferentes formas de acceder a la memoria, lo que añade flexibilidad.</li>
                                <li><b>Mayor consumo de energia:</b> Por lo general, CISC consume más energía debido a su complejidad.</li>
                            </ul>
                        </li>
                        <li>
                            <b>Aplicaciones:</b> Utilizados en computadoras personales, servidores y estaciones de trabajo donde la flexibilidad y la capacidad de realizar tareas complejas son cruciales.
                        </li>
                    </ul>
                    <br>

                    Los <b>microcontroladores</b> suelen ser <b>RISC (Reduced Instruction Set Computing)</b>, estos tienen un conjunto de instrucciones más pequeño y simplificado, optimizado para realizar operaciones básicas de manera rápida y eficiente. Esto es beneficioso para aplciaciones embebidas que requieren alta eficiencia y bajo consumo de energía.
                    <ul class="lista">
                        <li>
                            <b>Características</b>
                            <ul class="lista" style="list-style: circle;">
                                <li><b>Conjunto de instrucciones pequeño:</b> Hay menos instrucciones, lo que simplifica el diseño del procesador.</li>
                                <li><b>Simplicidad:</b> La arquitectura es más sencilla, lo que facilita su implementación.</li>
                                <li><b>Optimización para operaciones básicas:</b> Está diseñado para ejecutar instrucciones simples rápidamente.</li>
                                <li><b>Eficiencia en la ejecución:</b> Las instrucciones se ejecutan de manera más eficiente, gracias a la simplicidad del conjunto.</li>
                                <li><b>Pipeline:</b> Permite que diferentes etapas de ejecución de instrucciones se realicen simultáneamente, aumentando la eficiencia.</li>
                            </ul>
                        </li>

                        <li>
                            <b>Aplicaciones:</b> Ideal para aplicaciones embebidas que requieren alta eficiencia y bajo consumode energia, como electrodomésticos, automóviles, dispositivos médicos y sistemas de automatización industrial.
                        </li>                        
                    </ul>
                    <br>

                    Cabe destacar que el análisis de instrucción no es necesario en <b>RISC</b> porque no hay microprograma, RISC trabaja con <b>secuenciadores cableados.</b><br>
                    En cuanto al cálculo de la dirección del operando, las <b>transferencia se hacen entre registros</b>, y la búsqueda del operando no es necesaria ya que el <b>operando está en registros de acceso</b> muy rápido.<br>
                    Además, cada instruccion en RISC toma solo <b>un solo ciclo de reloj</b>, lo que constribuye a su alta eficiencia.
                    <br>

                    <div class="contenedor-imagen-tabla">
                        <table>
                            <tr>
                                <th> Características</th>
                                <th>RISC</th>
                                <th>CISC</th>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Simplicidad de instrucciones</b></td>
                                <td>Instrucciones simples, típicamente <b>1 ciclo de ejecución</b></td>
                                <td>Instrucciones complejas, pueden tomar <b>múltiples ciclos de ejecución</b></td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Acceso a Memoria</b></td>
                                <td>Referencias a memoria solo con instrucciones LOAD/STORE</td>
                                <td>Cualquier instrucción puede referenciar a la memoria.</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Pipeline</b></td>
                                <td>Más eficaz, con menos etapas</td>
                                <td>Menos eficaz, con más etapas</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Ejecución de instrucciones</b></td>
                                <td>Ejecutadas directamente por el <b>hardware</b></td>
                                <td>INterpretadas por un <b>microprograma</b></td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Formato de instrucciones</b></td>
                                <td>Formato <b>fijo</b> de instrucciones</td>
                                <td>Formato <b>variable</b> de instrucciones</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Cantidad de ejecuciones</b></td>
                                <td>Poca instruccioens y modos de instrucción</td>
                                <td>Muchas instrucciones y modos</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Complejidad del Sistema</b></td>
                                <td>La complejidad se encuentra en el <b>compilador</b></td>
                                <td>Complejidad en el <b>microprograma</b></td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Registro</b></td>
                                <td>Conjunto <b>múltiple</b> de registros</td>
                                <td>Conjunto <b>único</b> de registros</td>
                            </tr>
                        </table>
                    </div>
                    <br>

                    En conclusión, se puede decir que las máquinas RISC completan todas sus instrucciones en un solo ciclo de reloj, es por eso que es más rápida que las máquinas CISC, y en RISC contamos con un gran manejo de registros. Sin embargo, para efectuar una operación de mayor complejidad (como multipicaciones o divisiones) necesitamos más instrucciones como en CISC.<br>
                    Por eso un usuario debe definirse a favor o en contra de una arquitectura en función de la aplicación que desea realizar.
                </p>
                <br>

                <h2 class="titulo2"> PIPELINE EN MICROCONTROLADORES</h2> 
                <p>
                    El <b>pipeline</b> en los <b>microcontroladores es una técnica segmentada</b> utilizada para aumentar la eficiencia y la velocidad de procesamiento al dividir la <b>ejecución de una tarea en múltiples etapas independientes.</b><br>
                    Estas etapas pueden ejecutarse simultáneamente en diferentes partes del hardware del microcontrolador. 
                    <br>
                    
                    La tarea de ejecutar una instrucción se divide en varias etapas como:
                    <ul class="lista">
                        <li>la búsqueda de la instrucción (fetch), </li>
                        <li>la decodifcación (decode), </li>
                        <li>la ejecución (execute), </li>
                        <li>la memoria (memory), y </li>
                        <li>la escritura del resultado (write-back)</li>
                    </ul> 
                    <br>

                    Cada una de estas etapas puede trabajar en diferentes instruciones al mismo tiempo.<br>
                    <div class="cuadro">
                        Por ejemplo, mientras una instrucción está siendo decodificada, otra puede estar siendo buscada y otra puede estar siendo ejecutada. Sin embargo, las <u>dependencias</u> de datos y otros problemas pueden causar ralentizaciones, por lo que se requieren diversas estrategias para mitigar estos problemas y mantener el flujo de instrucciones lo más fluido posible.
                    </div>
                    <br><br>

                    <h3>Estrategias para mitigar problemas en el pipeline</h3>
                    <h4>Incluyen:</h4>
                    <ul class="lista">
                        <li>Interbloque (Stalling)</li>
                        <li>Reordenamiento de instrucciones</li>
                        <li>Bypassing / Forwarding</li>
                        <li>Predicción de saltos</li>
                    </ul>
                    <br>

                    <h4>Ventajas</h4>
                    <ul class="lista">
                        <li>Mayor rendimiento</li>
                        <li>Eficiencia</li>
                    </ul>
                    <br>

                    <h4>Desventajas</h4>
                    <ul class="lista">
                        <li>Interbloqueos</li>
                        <li>Complejidad de Control</li>
                    </ul>
                </p>
                <br>

                <h3>Comparación con Microprocesadores</h3>
                <p>
                    Los <b>microprocesadores</b>, diseñados para tareas más complejas y de alto rendimiento, implementan pipeline de manera más agresiva y sofisticada.<br>
                    Tienen más recursos disponibles y pueden permitirse un pipeline más profundo y complejo, lo cual mejora significativamente el rendimiento costa de mayor consumo de energía.<br><br>
                    Por otro lado, los <b>microcontroladores</b> están diseñados para aplicaciones específicas y de menor consumo energético, por lo que su implementación de pipeline tiende a ser más sencilla y menos profunda.
                </p>
                <br>

                <h3>Comparación con Procesador sin Pipeline</h3>
                <p>
                    <ul>
                        <li><b>Sin Pipeline: </b> Cada instrucción debe completarse antes de que la siguiente comience, lo que puede resultar en una ejecución más lenta.</li>
                        <li><b>Ventaja de Sin Pipeline: </b> Diseño más sencillo y menor complejidad en la unidad de control.</li>
                    </ul>
                </p>
                <br><br>

                <h2 class="titulo2">FORMATO DE INSTRUCCIONES ORTOGONAL</h2>
                <p>
                    El <b>formato de instrucciones ortogonal</b> es un diseño de conjunto de instrucciones en el que <b>cualquier operación puede ser realizada con cualquier registro o modo de direccionamiento disponible.</b> 
                    <br>Esto proporciona una gran flexibilidad y simplicidad en la programación, ya que permite utilizar <b>cualquier combinación de registros y modos de direccionamiento para cualquier instrucción.</b><br>
                    Sin embargo, este formato puede resultar en instrucciones de mayor tamaño, lo que aumenta la complejidad de decodificación, y también incrementa la complejidad del hardware al requerir soporte  para todas las combinaciones posibles.
                    <br><br>

                    <h4>Ventajas</h4>
                    <ul class="lista">
                        <li>Flexibilidad: Facilita la programación al permitir una mayor flexibilidad en el uso de registros y modos de direccionamiento.</li>
                        <li>Simplicidad: Simplifica el diseño del compilador y el código ensamblador</li>
                    </ul>
                    <br><br>

                    <h4>Desventajas</h4>
                    <ul class="lista">
                        <li>Tamaño de instrucciones: Puede resultar en isntrucciones de mayor tamaño, lo que aumenta la complejidad de decodificación.</li>
                        <li>Costo: Aumenta la complejidad de hardware, ya que se necesita soporte para todas las combinaciones posibles de registros y modos de direccionamiento.</li>
                    </ul>
                </p>
                <br><br>

                <h3>Amplio banco de registros:</h3>
                <p>
                    Un <b>amplio banco de registros</b> se refiere a disponer de una <b>gran cantidad de registros</b> accesibles por el procesador de operaciones rápidas. ESto reduce la necesidad de acceder a la memoria princial, acelerando el procesamiento y permitiendo que más variables temporales y datos intermedio se almacenan en registros, optimizando la eficiencia del código.<br>
                    Sin embargo, tener más registros puede complicar la gestión de contexto durante interrupciones o cambios de tarea, y aumentar el costo y la complejidad del hardware en comparación con un <b>banco de registro limitado</b>, que requiere más acceso a memoria y puede ralentizar el procesamiento, aunque <b>simplifica el diseño y reduce los costos</b>
                    <br><br>

                    <h4>Ventajas</h4>
                    <ul class="lista">
                        <li>Eficiencia: Reduce la necesidad de acceder a la memoria principal, lo que acelera el procesamiento.</li>
                        <li>Optimización de Código: Permite que más variables temporales y datos intermedios se almacenan en registros, mejorando la eficiencia del código.</li>
                    </ul>
                    <br><br>

                    <h4>Desventajas</h4>
                    <ul class="lista">
                        <li>Complejidad de manejo: Un mayor número de registros puede complicar la gestión de contexto durante interrupciones o cambios de tarea.</li>
                        <li>Costo de hardware: Más registros pueden aumentar el costo y la complejidad del hardware</li>
                    </ul>
                    <br><br>

                    <h4>Comparación de Regitro Limitado</h4>
                    <ul class="lista">
                        <li>Registros limitados: Menos registros requieren más accesos a memoria, lo que puede ralentizar el procesamiento.</li>
                        <li>Ventaja de registros limitados: Diseño más sencillo y menor costo de hardware.</li>
                    </ul>
                </p>

                <button onclick="scrollToTop('microcontroladores')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** PIPELINE -->
            <section id="pipeline" class="contenido">
                <h2 class="titulo2">PIPELINE</h2>
                <p>
                    Pipeline es una técnica utilizada en los procesadores para mejorar su rendimiento, permitiendo que varias instrucciones se ejecuten al mismo tiempo pero en diferentes <b>etapas</b> del proceso.</b><br>
                    La ejecución de <b>una instrucción se divide en varias etapas, y múltiples instrucciones pueden estar en diferentes etapas simultáneamente</b>, lo que permite que el procesador trabaje en varias instrucciones al mismo tiempo.
                </p>
                <br>

                <h3>Beneficios</h3>
                <ul class="lista">
                    <li><b>Aumento del rendimiento:</b> Incrementa el número de instruccioens que se pueden ejecutar por unidad de tiempo.</li>
                    <li><b>Paralelismo implícito:</b> Cada etapa del pipeline traba en una instrucción diferente simultáneamente.</li>
                    <li><b>Aprovechameinto de recursos:</b> Permite un uso más eficiente de los recursos del procesador.</li>
                    <li><b>Reducción del tiempo de ejecución promedio:</b> Reduce el tiempo promedio por instrucción en un flujo continuo de instrucciones.</li>
                    <li><b>Frecuencia de reloj mas alta:</b> Al dividir el trabajo en etapas más pequeñas, cada etapa puede completarse más rápidamente, permitiendo una frecuencia de reloj potencialmente más alta.</li>
                </ul>
                <br>

                <h3>Aplicaciones</h3>
                <ul class="lista">
                    <li><b>Procesadores de Alto Rendimiento:</b> Utilizado ampliamente en procesadores modernos para mejorar el rendimiento en aplicaciones de alta demanda, como gráficos, juegos, procesamiento de datos y servidores</li>
                    <li><b>Microcontroladores Avanzados:</b> Algunos microcontroladores también incorporan pipelines para mejorar su eficiencia en apilcaciones embebidas críticas.</li>
                </ul>
                <br>

                <h3>Instrucciones que generan problemas:</h3>
                <p>
                    Las instrucciones de salto (tanto condicionales como incondicionales) son aquellas que alteran el flujo normal de ejecución de un programa.<br>
                    Por ejemplo, si tienes una instrucción que dice <i>"si la condición se cumple, ve a la línea X"</i>, esto puede causar que el procesador se detenga y cambie de dirección, lo que interrumpe el flujo del pipeline.<br>
                    Si se efectúa un salto, las etapas que se hayan ejecutado de las instrucciones siguientes del pipeline <b>no sirven y se deben limpiar todos los registros.</b>
                </p>
                <br>

                <h3>Soluciones</h3>
                <ul class="lista">
                    <li>
                        <b>Dejar de cargar el pipeline hasta atender el salto (Detener el Pipeline):</b><br>
                        - <b>Descripción:</b> Cuando se detecta un salto, el pipeline se detiene y espera a que se procese el salto antes de continuar.<br>
                        - <b>Desventaja:</b> Este método es ineficiente porque hay un período de tiempo en el que no se están ejecutando instrucciones, lo que disminuye el rendimiento.
                            <!--Esto no es muy efectivo debido a que la espera tarda mucho tiempo y no se ahce nada durante la misma.-->
                    </li>
                    <br>

                    <li>
                        <b>Tratar el salto como una instrucción Normal (y seguir cargando el pipeline).</b><br>
                        - <b>Descripción:</b> Continuar cargando el pipeline incluso si hay un salto. Si se ejecuta el salto, se limpia el pipeline y se empieza a cargar desde la nueva dirección.<br>
                        - <b>Desventaja:</b> Similar al primero, limpiar el pipeline también toma tiempo y recursos, ya que debes restaurar los registros a su estado anterior.
                        
                        <!--
                            Si el salto es existoso, se limpia el pipeline y se cargar a partir de la posición a la que lleva el salto.<br>
                            Sin embargo, tampoco es muy efectiva, debido a que la limpieza del pipeline demanda mucho tiempo. Limpiar consiste en volver a cargar el valor de los registros que las instrucciones hayan modificado; para esto se necesita guardar los valores previos.
                        -->
                    </li>
                    <br>

                    <li>
                        <b>Predicción de saltos:</b><br>
                        - <b>Descripción:</b> Intentar anticipar si un salto se realizará o no. Esto se puede hacer de dos maneras:
                        <div class="contenedor-imagen-tabla">
                            <u>Estática:</u> El compilador predice el comportamiento de los saltos basándose en el análisis del código. Por ejemplo, puede asumir que un salto condicional a menudo se cumple.<br><br> 
                            <u>Dinámica:</u> Se registran las decisiones de salto en tiempo de ejecución. Se crea una tabla que guarda el historial de saltos anteriores, utilizando un contador (o bits) para ayudar a predecir si el salto ocurrirá. Si el salto se efectúa, se incrementa el contador; si no, se decrementa.<br>
                        </div><br>
                        - <b>Ventaja:</b> Esta técnica puede reducir el número de veces que se necesita limpiar el pipeline, mejorando el rendimiento en general.
                        </li>
                        <!--
                            Consiste en predecir los saltos anotando el comportamiento del programa en saltos anteriores. Puede ser estática o dinámica.
                            <ul>
                                <li><b>Estática:</b> El compilador hace una suposición por cad auan de las isntrucciones de salto que genera.</li>
                                <li><b>Dinámica:</b> En tiempo de ejecución, el microprograma constituye una tabla con las direcciones que contiene saltos y guarda un registro de comportamientos de cada uno (si se efectuó o no). Se asocian dos o más bits a cada isntrucción de salto, que actúan como un contador: si el salto se efectúa se suma, si no se efectuó se resta.</li>
                            </ul></li>
                        -->
                </ul>
                <br>

                <h3>PIPELINE genérico de cinco etapas de una máquina-CISC</h3>
                <p>En un procesador clásico, la ejecución de una instrucción se divide en varias etapas, como:</p>
                <ol>
                    <li><b>Fetch (Búsqueda):</b> Obtener la instrucción de la memoria. Se obtiene la instrucción de la memoria de instrucciones y se carga en el registro de instrucciones.</li>
                    <li><b>Decode (Decodificación):</b> Decodificar la instrucción y lees los registros fuente. La instrucción se decodifica (interpreta) para determinar qué operación se va a realizar, y se leen los registros fuentes necesarios.</li>
                    <li><b>Execute (Ejecución):</b> Realizar la operación aritmética o lógica (ALU). Se realiza la operación aritmética o lógica especificada por la instrucción.</li>
                    <li><b>Memory Acces (Memoria):</b> Acceder a la memoria para leer o escribir datos. <b>Si la instrucción es una opearción de carga o almacenamiento,</b> se accede a la memoria para leer o escribir datos.</li>
                    <li><b>Write Back (Escritura):</b> Escribir el resultado en los registros. <b>El resultado de la operación se escribe</b> en el registro de destino.</li>
                </ol>
                <br>
                <!--
                    Fetch (Búsqueda): Se lee la instrucción de la memoria.
                    Decode (Decodificación): Se interpreta qué hace la instrucción.
                    Execute (Ejecución): Se realiza la operación (por ejemplo, una suma).
                    Memory (Memoria): Se leen o escriben datos en la memoria (si es necesario).
                    Write-back (Escritura): Se guarda el resultado en un registro.
                    Sin pipeline, cada instrucción se ejecutaría por completo antes de pasar a la siguiente, como si una persona tuviera que terminar un producto antes de comenzar otro.
                -->
                <div class="cuadro">
                    <p>
                        <h4><u>Ejemplo en acción</u></h4>
                        <br>
                        Supongamos que tenemos las siguientes instrucciones en secuencia:
                        <ul class="lista">
                            <li>CARGAR A: Carga un valor en el registro A.</li>
                            <li>CARGAR B: Carga un valor en el registro B.</li>
                            <li>SUMAR A, B: Suma los valores de A y B.</li>
                            <li>ALMACENAR C: Almacena el resultado en la dirección de memoria C.</li>
                        </ul>
                        <br>

                        <h4><u>Funcionamiento del Pipeline:</u></h4>
                        <ul class="lista">
                            <li>Ciclo 1: En el ciclo de reloj 1, se obtiene (fetch) la instrucción "CARGAR A".</li>
                            <li>Ciclo 2: En el ciclo 2, se decodifica (decode) "CARGAR A" y se obtiene la instrucción "CARGAR B".</li>
                            <li>Ciclo 3: En el ciclo 3, se ejecuta (execute) "CARGAR A" y se obtiene "SUMAR A, B".</li>
                            <li>Ciclo 4: En el ciclo 4, se accede a la memoria (memory access) para "CARGAR B" y se ejecuta "SUMAR A, B".</li>
                            <li>Ciclo 5: En el ciclo 5, se escribe de vuelta (write back) el resultado de "SUMAR A, B" y se accede a la memoria para "ALMACENAR C".</li>
                        </ul>
                    </p>
                </div>
            <p>
                Cada etapa de pipeline puede procesar una instrucción diferente simultáneamente. Esto significa que mientras una instrucción está en la etapa de decodificación, otra puede estar en la etapa de búsqueda y otra en la etapa de ejecución. De esta manera, múltiples instrucciones pueden estar en diferentes etapas del pipeline al mismo tiempo, permitiendo que el procesador trabaje en varias instrucciones simultáneamente.
            </p>
            <br>

            <h3>Diagrama de tiempo indicando la ejecución de instrucciones en ese PIPELINE de 5 etapas:</h3>
                <img src="images/adc-pipeline.png" alt="pipeline" style="width: 600px;">
                <div class="contenedor-imagen-tabla">
                    <table>
                        <tr>
                            <th> CICLO</th>
                            <th>1</th>
                            <th>2</th>
                            <th>3</th>
                            <th>4</th>
                            <th>5</th>
                            <th>6</th>
                            <th>7</th>
                            <th>8</th>
                            <th>9</th>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Fetch</td>
                            <td>A</td>
                            <td>B</td>
                            <td>C</td>
                            <td>D</td>
                            <td>E</td>
                            <td>F</td>
                            <td>G</td>
                            <td>H</td>
                            <td>I</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Decode</td>
                            <td>-</td>
                            <td>A</td>
                            <td>B</td>
                            <td>C</td>
                            <td>D</td>
                            <td>E</td>
                            <td>F</td>
                            <td>G</td>
                            <td>H</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Execute</td>
                            <td>-</td>
                            <td>-</td>
                            <td>A</td>
                            <td>B</td>
                            <td>C</td>
                            <td>D</td>
                            <td>E</td>
                            <td>F</td>
                            <td>G</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Memory Access</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                            <td>A</td>
                            <td>B</td>
                            <td>C</td>
                            <td>D</td>
                            <td>E</td>
                            <td>F</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Write Back</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                            <td>A</td>
                            <td>B</td>
                            <td>C</td>
                            <td>D</td>
                            <td>E</td>
                        </tr>
                    </table>
                </div>
                <br>

                <h4>Explicación:</h4>
                    <ol>
                        <li><b>Ciclo 1:</b> Se inicia el <b>Fetch</b> de la instrucción <b style="color: brown;">A</b></li>
                        <li><b>Ciclo 2:</b> <b style="color: brown;"> A</b> pasa a <b>Decode</b>, mientras <b style="color: rgb(43, 82, 43);">B</b> inicia su <b>Fetch</b></li>
                        <li><b>Ciclo 3:</b> <b style="color: brown;"> A</b> pasa a <b>Execute</b>, <b style="color: rgb(43, 82, 43);">B</b> a <b>Decode</b>, <b style="color: rgb(100, 100, 185);"">C</b> inicia su <b>Fetch</b></li>
                        <li><b>Ciclo 4:</b> <b style="color: brown;"> A</b> pasa a <b>Memory Access</b>, <b style="color: rgb(43, 82, 43);">B</b> a <b>Execute</b>, <b style="color: rgb(100, 100, 185);"">C</b> a <b>Decode</b>,<b style="color: rgb(185, 176, 100);""> D</b> inicia su <b>Fetch</b></li>
                        <li><b>Ciclo 5:</b> <b style="color: brown;"> A</b> pasa a <b>Write Back</b>, <b style="color: rgb(43, 82, 43);">B</b> a <b>Memory Access</b>, <b style="color: rgb(100, 100, 185);"">C</b> a <b>Execute</b>,<b style="color: rgb(185, 176, 100);""> D</b> a <b>Decode</b>, <b style="color: rgb(100, 179, 185);""> E</b> inicia su <b>Fetch</b></li>
                    </ol>
                    A partir del ciclo 5, el pipeline está completamente lleno y se están procesanto 5 instrucciones simultánemaente, una en cada etapa.
                    <br><br>

                    Este diagrma muestra claramente:
                    <ol>
                        <li>Las 5 etapas de pipeline CISC (Fetch, Decode, Execute, Memory Access, Write Back)</li>
                        <li>Cómo múltiples instrucciones (A, B, C, etc.) avanzan por las etapas del pipeline.</li>
                        <li>El paralelismo alcanzado, con una nueva instrucción iniciando cada ciclo.</li>
                        <li>Que a partir del ciclo 5, se completa una instrucción por ciclo (aunque cada instrucción tarda 5 ciclos en completarse).</li>
                    </ol>
                    <br>

                <h4>Cuadro con ejemplo dado previamente:</h4>
                <div class="contenedor-imagen-tabla">
                    <table>
                        <tr>
                            <th>CICLO DE RELOJ</th>
                            <th>CARGAR A</th>
                            <th>CARGAR B</th>
                            <th>SUMAR A,B</th>
                            <th>ALMACENAR C</th>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">1</td>
                            <td>Fetch</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">2</td>
                            <td>Decode</td>
                            <td>Fetch</td>
                            <td>-</td>
                            <td>-</td>

                        </tr>
                        <tr>
                            <td class="fila-descripcion">3</td>
                            <td>Execute</td>
                            <td>Decode</td>
                            <td>Fetch</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">4</td>
                            <td>Memory Access</td>
                            <td>Execute</td>
                            <td>Decode</td>
                            <td>Fetch</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">5</td>
                            <td>Write Back</td>
                            <td>Memory Acces</td>
                            <td>Execute</td>
                            <td>Decode</td>
                        </tr>
                        <tr></tr>
                            <td class="fila-descripcion">5</td>
                            <td>-</td>
                            <td>Write Back</td>
                            <td>Memory Acces</td>
                            <td>Execute</td>
                        </tr>
                    </table>
                </div>
                <br>

                <h4>Ciclos de reloj:</h4>
                <ul class="lista">
                    <li>Ciclo 1: CARGAR A (Fetch): La instrucción CARGAR A se está obteniendo de la memoria. En este ciclo, el procesador está buscando la instrucción y cargándola en el registro de instrucciones..</li>
                    <li>Ciclo 2: "CARGAR A" se decodifica (Decode), mientras que "CARGAR B" se obtiene (Fetch).</li>
                    <li>Ciclo 3: "CARGAR B" se decodifica (Decode) y "SUMAR A, B" se obtiene (Fetch).</li>
                    <li>Ciclo 4: "SUMAR A, B" se decodifica (Decode) y "CARGAR A" se ejecuta (Execute). También, "ALMACENAR C" se obtiene (Fetch).</li>
                    <li>Ciclo 5: "ALMACENAR C" se decodifica (Decode), "SUMAR A, B" se ejecuta (Execute) y "CARGAR A" realiza la operación de acceso a memoria (Memory Access).</li>
                    <li>Ciclo 6: "CARGAR A" escribe de vuelta el resultado (Write Back).</li>
                </ul>
                <br>
                
                <h3>Pipeline en RISC</h3>
                <p>
                    El pipeline en arquitecturas RISC (Reduced Instruction Set Computing) se caracteriza por su simplicidad y eficiencia, consta de solos dos etapas principales:
                    <ol>
                        <li><b>Búsqueda del operando:</b> En esta fase, el procesador localiza y obtiene los datos necesarios para ejecutar la instrucción. Estos datos suelen estar en <b>registros</b>, lo que permite un acceso rápido.</li>
                        <li><b>Ejecución de la instrucción:</b> Una vez obtenidos los operandos, el procesador realiza la operación especificada por la instrucción.</li>
                    </ol><br>

                    A diferencia de las arquitecturas CISC (Complex Instruction Set Computing), RISC, no necesariamente utiliza una etapa de análisis de instrucciones compleja.<br>
                    Esto se debe a que, en muchos casos, <b>RISC no emplea micropogramación</b>, sino que puede traba con secuenciadores cableados, lo que significa que las instrucciones están directamente implementadas en hardware.<br>
                    Las operaciones en RISC se realizan principalmente entre registros, lo que incluye el cálculo de direcciones de operandos y las transferencias de datos. Este enfoque de registros a registro contribuye a la velocidad y eficiencia del pipeline.<br>
                    La arquitectura RISC se beneficia aún más cuando se implementa en una arquitectura Harvard. Esta combinación permite la separación física de las memorias de instruccioens y datos, posiblitando el acceso simultáneo a ambas y aumentando así el rendimiento del pipeline.
                    <br><br>

                    Aunque optimizada, la segmentación en RISC, sigue presentando ciertos problemas. Anteriorimente, vimos que las instrucciones de salto y las lecturas a memoria generan complicaciones al segmentar instrucciones.<br>
                    Para soluciones estos problemas, el compilador o ensamblador puede insertar una operación NOOP en el flujo de instrucciones. La instrucción <b>NOOP, irónicamente, no realiza ninguna operación sobre los datos. En cambio, resulta útil para generar un retardo en el flujo de instrucciones.</b> Esto es necesario cuando, en una operación segmentada, se necesita evaluar una condición de salto o cuando una instrucción depende de un dato que está a punto de ser actualizado, y usualmente se coloca después de que todos los registros involucrados han sido cargados o escritos.
                    <br><br>

                    Existe una forma de optimizar el programa mediante estos retardos, especificamente utilizando lo que se conoce como salto retardado y salto retardado optimizado.
                    <ul class="lista">
                        <li><b>Salto Retardado:</b> Consiste en colocar un NOOP después del salto. Esto tiene la ventaja de que, para cuando el flujo del programa alcanza el NOOP, la instrucción de salto ya se está ejecutando y el salto ya se habrá realizado. Además, el programa no tiene que esperar hasta completar una operación de lectura/escritura realizada previamente para saltar, <b>garantizando que nose comience a buscar la operación siguiente al salto antes de tiempo.</b></li>
                        <li><b>Salto con Retardo Optimizado:</b> Hace algo similar, pero reemplaza el NOOP por la instrucción previa al salto, intercambiando sus lugares. Así, primero se evalúa y ejecuta el salto. Dado que la instrucción anterior era necesaria y al mismo tiempo es la próxima a ejecutarse, se garantiza que el salto se realice correctamente y que la instrucción con la que se cambío de lugar ya esté en proceso de búsqueda para su ejecución.</li>
                    </ul><br>

                    <b>Cabe destacar que este último método sólo se aplica a saltos incondicionales, llamdas y retornos.</b> Para saltos condicionales, el compilador utiliza un salto con retardo normal, insterando el NOOP después del salto. De esta forma, al evaluar la condición del salto, no se realiza ninguna otra operación que comprometa el estado del procesador y de los registros.
                </p>
                <button onclick="scrollToTop('pipeline')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** ENTRADA - SALIDA -->
            <section id="entrada-salida" class="contenido">
                <h2 class="titulo2">Entrada - Salida</h2>
                
                <button onclick="scrollToTop('entrada-salida')">▲</button>
            </section>

            <!-- ********************************************************************************************************** PARALELISMO -->
            <section id="paralelismo" class="contenido">
                <h2>Paralelismo</h2>
                <p>PARALELISMO</p>
                <button onclick="scrollToTop('paralelismo')">▲</button>
            </section>

            <!-- ********************************************************************************************************** SECUENCIADORES -->
            <section id="secuenciadores" class="contenido">
                <h2>SECUENCIADORES</h2>
                <p>Descripción detallada sobre los sistemas de SECUENCIADORES</p>
                <button onclick="scrollToTop('secuenciadores')">▲</button>
            </section>

            

            <!-- ********************************************************************************************************** MEMORIA CACHE -->
            <section id="memoria-cache" class="contenido">
                <h2>Memoria Caché</h2>
                <p>Funcionamiento de la memoria caché y su importancia en la arquitectura de computadoras.</p>
                <button onclick="scrollToTop('memoria-cache')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** COHERENCIA CACHE -->
            <section id="coherencia-cache" class="contenido">
                <h2>Coherencia Caché</h2>
                <p>Funcionamiento de la memoria caché y su importancia en la arquitectura de computadoras.</p>
                <button onclick="scrollToTop('coherencia-cache')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** EXAMENES -->
            <section id="examenes" class="contenido">
                <h2>Exámenes</h2>
                <p>
                    Listado de los exámenes recolectados.
                </p>
                <br>

                <!-- MICROCONTROLADORES -->
                <h2 class="titulo2">MICROCONTROLADORES</h2>
                <b class="negrita-color">AÑO 2023</b>
                <ul class="lista">
                    <li>¿Qué son y que los diferencia de los microprocesadores?</li>
                    <li>¿Qué tipo de Arquitectura tienen?</li>
                    <li>Son CISC o RISC? Detalle porqué y que caracteristicas incluye.</li>
                    <li>¿Cómo es el pipeline en los microcontroladores?</li>
                </ul>
                <br>
                
                <b class="negrita-color">AÑO 2024</b>
                <ul class="lista">
                    <li>Describa las principales características de los microcontroladores.</li>
                </ul>
                <br>

                <!-- INTERRUPCIONES-->
                <h2 class="titulo2">INTERRUPCIONES</h2>
                <b class="negrita-color">AÑO 2023 | 2024</b>
                <ul class="lista">
                    <li>Describa el funcionamiento general y su utilidad.</li>
                    <li>Describa en detalle cómo es el mecnaismo de interrupciones, incluyendo el uso de la pila.</li>
                    <li>Interrupciones anidadas y secuenciales.</li>
                    <li>Propiedades.</li>
                    <li>Rutinas de Servicio (ISR), su localización y acceso a ellas.</li>
                </ul>
                <br>

                <!-- PIPELINE -->
                <h2 class="titulo2">PIPELINE</h2>
                <b class="negrita-color">AÑO 2023 | 2024</b>
                <ul class="lista">
                    <li>En que consiste y cual es el beneficio que brinda.</li>
                    <li>Que instrucciones generan problemas, por qué, y que soluciones utiliza.</li>
                    <li>Grafique un pipeline genérico de cinco etapas de una máquina CISC y describa la función de cada una de ellas.</li>
                    <li>Grafique un diagrama de tiempo indicando la ejecución de instrucciones en ese pipeline de 5 etapas.</li>
                </ul>
                <br>

                <!-- SECUENCIADORES -->
                <h2 class="titulo2">SECUENCIADORES</h2>
                <b class="negrita-color">AÑO 2023</b>
                <ul class="lista">
                    <li>¿Para qué arquitecturas son adecuados los secuenciadores micrprogramados?</li>
                    <li>¿Para qué arquitecturas son adecuados los secuenciadores cableados?</li>
                </ul>
                <b class="negrita-color">AÑO 2024</b>
                <ul class="lista">
                    <li>Describa los secuenciadores de tipo cableados en detalles.</li>
                    <li>Describa los secuenciadores microprogramados.</li>
                    <li>Modelo de Wilkes.</li>
                    <li>Direccionamiento implícito y explícito.</li>
                    <li>Microprogramación vertical y horizontal.</li>
                    <li>Microinstrucciones por micro orden o por campo.</li>
                </ul>

                <!-- PARALELISMO -->
                <h2 class="titulo2">PARALELISMO</h2>
                <b class="negrita-color">AÑO 2023 | 2024</b>
                <ul class="lista">
                    <li>Describa la clasificación de Flynn</li>
                    <li>Respecto a MIMD, describa en detalle multicomputadores y multiprocesadores</li>
                    <li>Caracteristicas</li>
                    <li>Diferencias</li>
                </ul>

                <!-- MEMORIA CACHÉ -->
                <h2 class="titulo2">MEMORIA CACHE</h2>
                <b class="negrita-color">AÑO 2024</b>
                <ul class="lista">
                    <li>Describa el objetivo de las memorias caché y como se implementan.</li>
                    <li>Describa su funcionamiento, funciones de mapeo y algoritmos de reemplazo.</li>
                </ul>








                <button onclick="scrollToTop('examenes')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <div id="content-display" class="contenido">Selecciona una materia para ver su contenido aquí.</div>
        </main>

    </div>

    <script src="scriptM.js"></script>
</body>
</html>
