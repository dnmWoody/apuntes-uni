<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADC - Arquitectura de Computadoras</title>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <link rel="stylesheet" href="styleM.css">
</head>
<body>
    <div class="container">
        <aside class="sidebar" id="sidebar">
            <h2>Contenido</h2>
            <ul>
                <li><a href="#interrupciones" onclick="hideMenu()">Interrupciones</a></li>
                <li><a href="#microcontroladores" onclick="hideMenu()">Microcontroladores</a></li>
                <li><a href="#pipeline" onclick="hideMenu()">Pipeline</a></li>
                <li><a href="#entrada-salida" onclick="hideMenu()">Entrada - Salida</a></li>
                <li><a href="#paralelismo" onclick="hideMenu()">Paralelismo</a></li>
                <li><a href="#secuenciadores" onclick="hideMenu()">Secuenciadores</a></li>
                <li><a href="#memoria-cache" onclick="hideMenu()">Memoria Caché</a></li>
                <li><a href="#coherencia-cache" onclick="hideMenu()">Coherencia Caché</a></li>
                <li><a href="#examenes" onclick="hideMenu()">Exámenes</a></li>
                <li><a href="../index.html" onclick="hideMenu()" style="color: rgb(207, 89, 89);">← Volver atrás</a></li>
            </ul>
            <button class="theme-toggle" onclick="toggleTheme()">Cambiar Tema</button>
        </aside>

        <!-- Botón para mostrar el menú cuando esté oculto en modo responsive -->
        <button id="show-menu-btn" class="show-menu-btn" onclick="toggleMenu()">Menú</button>
        <!--<button id="show-atras-btn" class="show-atras-btn"><a href="../index.html">Volver atrás</a></button>-->


        <main class="main-content" id="main-content">
            <!-- ********************************************************************************************************** INTERRUPCIONES -->
            <section id="interrupciones" class="contenido">
                <h2 class="titulo2">Interrupciones</h2>
                <p>Las interrupciones son cambios en el flujo de control causados no por el programa en ejecución, sino por eventos externos al mismo, como los relacionados con operaciones de E/S (Entrada/Salida).<br>
                    Por ejemplo, un disco duro que realiza una transferencia puede interrumpir el flujo normal de trabajo cuando finaliza la operación. Otro ejemplo es el teclado: al presionar una tecla, se genera una interrupción.<br>
                    Cuando se habla de interrupciones, se hace referencia a la detención temporal del flujo normal de ejecución del procesador, transfiriendo el control a la unidad manejadora de interrupciones, que se encargará de realizar la acción apropiada.<br>
                    Una vez finalizada la acción, el control debe ser devuelto al proceso interrumpido, restaurando los registros y el estado interno del sistema tal como estaban antes de la interrupción.<br>
                    Las interrupciones son asíncronas, lo que significa que pueden ocurrir en cualquier momento, ya que no son controladas directamente por el programa en ejecución.
                </p>
                <br>

                <h3>Mecanismo de interrupciones (Paso a Paso)</h3>
                <ol>
                    <li><b>El dispositivo genera una interrupción:</b> 
                        <br>Un dispositivo, como el teclado o un disco duro, necesita atención de la CPU, por lo que envía una señal de interrupción a través del bus del sistema, que es la conexión física entre los componentes de la computadora.</li>
                    <li><b>La CPU está lista para manejar la interrupción:</b>
                        <br> La CPU sigue trabajando en sus tareas hasta que pueda atender la interrupción. Una vez que esté lista, envía una señal de reconocimiento para decirle al dispositivo que la interrupción ha sido registrada.</li>
                    <li><b>Identificación del dispositivo que generó la interrupción:</b>
                        <br>El dispositivo coloca un número, llamado <b>vector de interrupción</b>, en el bus de datos. Este número identifica qué dispositivo solicitó la interrupción.</li>
                    <li><b>La CPU toma el vector de interrupción: </b>
                        <br> La CPU guarda temporalmente ese número (el vector de interrupción), que servirá para localizar la rutina que debe ejecutarse para manejar la interrupción.</li>
                    <li><b>La CPU guarda su estado actual: </b> 
                        <br> La CPU necesita recordar en qué punto estaba ejecutando el programa cuando ocurrió la interrupción. Para ello, guarda el <b>contador de programa</b> (que le dice qué instrucción estaba ejecutando) y el <b>estado del programa</b> (valores de los registros y otros datos importantes) en la pila, una zona de la memoria.</li>
                    <li><b>La CPU localiza la rutina de manejo de interrupciones: </b>
                        <br>Usando el vector de interrupción, la CPU busca una tabla especial en la memoria (ubicada en la parte baja de la memoria) que le indica dónde está la <b>rutina de servicio de interrupción</b>, que es el código que se va a ejecutar para manejar la interrupción.</li>
                    <li><b>Guardado de registros: </b>
                        <br>La rutina de servicio de interrupción guarda todos los registros (información importante que estaba usando la CPU), para poder restaurarlos después de atender la interrupción. Estos se guardan en la pila o en una tabla del sistema.</li>
                    <li><b>Identificación específica del dispositivo: </b>
                        <br>A veces, varios dispositivos pueden compartir el mismo vector de interrupción. En este caso, la CPU debe leer un registro en el dispositivo para saber cuál de ellos exactamente generó la interrupción (por ejemplo, si fue el teclado o un ratón).</li>
                    <li><b> Lectura de la información sobre la interrupción: </b>
                        <br>La CPU recoge toda la información adicional que necesita sobre el evento que causó la interrupción, como códigos de error o datos específicos del dispositivo.</li>
                    <li><b>Manejo de errores de E/S: </b>
                        <br>Si hubo algún error durante la operación de entrada/salida (E/S), como un problema al leer del disco duro, la rutina de servicio se encarga de solucionarlo aquí.</li>
                    <li><b>Actualización de variables: </b>
                        <br>Si la interrupción requiere que se actualicen contadores o variables globales, como el número de datos procesados, esto se hace en este paso.</li>
                    <li><b>Notificación al dispositivo: </b>
                        <br>Una vez procesada la interrupción, la CPU puede enviar un código al dispositivo para indicarle que la interrupción ha sido manejada correctamente.</li>
                    <li><b>Restauración del estado previo: </b>
                        <br>Se restauran los registros que fueron guardados para que la CPU vuelva exactamente al estado en el que estaba antes de la interrupción.</li>
                    <li><b>Reaundación del trabajo: </b>
                        <br>Finalmente, la CPU ejecuta una instrucción especial que la devuelve al estado anterior y continúa ejecutando el programa desde donde fue interrumpido.</li>
                </ol>
                
                <p>
                    Este proceso ocurre muy rápido, casi de manera instantánea, y por eso se puede, por ejemplo escribir en un teclado, seguir escribiendo sin notar ningún retraso. 
                </p>
                <br>

                <h3>Interrupciones Anidadas</h3>
                <p>
                    Las interrupciones anidadas permite que una interrupción de baja prioridad sea interrumpida por otra de alta prioridad, creando así una pila de interrupciones donde cada nivel se guarde su propio estado.<br>
                    Este mecanismo permite que los eventos más críticos puedan ser atendidos de inmediato. <br>
                    Cuando una ocurre la interrupción durante el manejo de otra interrupción, el estado de la CPU (registros, contador de programa y la palabra del estado del programa), se guarda en una estructura de pila. Esta pila sigue el principio de LIFO (Last In, First Out), lo que significa que la ultima interrupción en ser atendida es la primera en ser completada.
                </p>
                <br>

                <h3>Interrupciones Secuenciales</h3>
                <p>
                    Las interrupciones secuenciales se basa en manejar una interrupción a la vez antes de atender la siguiente, completando la ISR (Interrupt Service Routine).<br>
                    Aunque este método es simple, puede existir ciertas desventajas ya que existen interrupciones de diferentes prioridades. <br>
                    En estos casos, el sistema debe esperar que se complete la interrupción actual antes de antender la siguiente, lo que puede resultar demoras significativas si una interrupción de alto prioridad ocurre mientras se está manejando una interrupción de baja prioridad.<br>
                    Esto puede generar efectos negativos en la capacidad de respuesta del sistema y su desempeño general, especialmente en aplicaciones de tiempo real donde la rapidez es crítica.
                </p>
                <br>

                <h2>Ampliación de conceptos: Prioridades, Rutinas de Servicio (ISR), su ubicación y acceso a ellas</h2>
                <h3>Prioridades</h3>
                <p>
                    En un sistema de interrupciones, es crucial tener un mecnaismo para poder priorizar y manejar interrupciones mas urgentes. Existen varias alternativas para la gestión de interrupciones: 
                    <ul class="lista">
                        <li> <b>Interrupciones anidadas:</b> Permiten que una interrupción sea interrumpida por otra de mayor gravedad. Esto se logra guardadno el estado de la interrupción actual y atendiendo primero la interrupción más crítica. Este método asegura que las interrupciones más urfentes sean tratadas inmediatamente, mejorando la capacidad de respuesta del sistema.</li>
                        <li> <b>Inhabilitación de interrupciones:</b> Consiste en deshablitar todas las interrupciones mientras se está atendiendo una. Este enfoque simplifica el manejo de interrupciones, pero resulta ineficiente en sistemas donde las interrupciones mas críticas deben ser atendidas sin demora.</li>
                    </ul>
                    <br>
                    
                    <i>Tener interrupciones manejadas por prioridad es más efectivo y logra un sistema mas equilibrado mejorando así el rendimiento del sistema en aplicaciones de tiempo real.</i>
                </p>
                <br>

                <h3>Rutinas de Servicio de Interrupciones (ISR)</h4>
                <p>
                    Las <b>ISR (Interrupt Service Routines)</b> son programas especiales que se ejecutan automáticamente para <i>atender eventos específicos</i> llamados <b>interrupciones</b>. El objetivo principal de cada ISR es <i>gestionar el evento que causó la interrupción y restaurar el sistema</i> para que continúe funcionando normalmente. 
                    <div class="cuadro">
                        <b>Ejemplo Claro de ISR:</b><br>
                        Imagina que estás viendo una película en tu computadora y recibes un mensaje en WhatsApp.<br>
                        La interrupción es el mensaje entrante. El sistema operativo pausa la película momentáneamente, abre WhatsApp para mostrarte la notificación, y luego retoma la película donde se quedó.
                    </div>
                    <br>
                    
                    <ul class="lista">
                        <li>
                            <b>Ubicación de la ISR:</b> Las direcciones de las ISR se encuentran en una estructura conocida como vector de interrupciones que es una tabla en memoria. Cada entrada de la tabla contiene la dirección de inicio de una ISR específica.
                            <div class="cuadro">
                                Si presionas una tecla en tu teclado, la CPU consulta el vector de interrupciones para encontrar la dirección exacta de la ISR que maneja las pulsaciones. Luego, esa ISR registra la tecla que presionaste y permite que sigas usando la computadora sin problemas.
                            </div>
                        </li>
                        <br>
                        
                        <li>
                            <b>Acceso a las ISR:</b> Cuando ocurre la interrupción, el procesador consulta el vector de interrupciones utilizando el número de interrupción para obtener la dirección de la ISR correspondiente. Este número de interrupción actúa como un índice en la tabla del vector. EL procesador luego transfiere el control a la ISR para manejar la interrupción.
                        </li>
                        <br>
                        
                        <i>
                            El diseño eficiente y la correcta ubicación de las ISR son cruciales para el manejo efectivo de las interrupciones. <br> 
                            Al tener una tabla centralizada, el sistema puede acceder de forma rápida a la ISR necesaria, garantizando así la respuesta rápida al evento.   
                        </i>
                    </ul>
                </p>
                <br>
                
                <h3>Beneficios de la Prioridad en Interrupciones y ISR</h3>
                <ul class="lista">
                    <li><b>Mejora de la Respuesta del Sistema:</b> Las interrupciones más urgentes se manejan primero, garantizando que eventos críticos, como alarmas, reciban atención inmediata.</li>
                    <li><b>Optimización de Recursos:</b> La CPU no pierde tiempo en tareas menos importantes si hay eventos prioritarios que atender.</li> <li><b>Mantenimiento de la Integridad del Sistema:</b> Al procesar interrupciones en el orden adecuado, se evita que el sistema falle o se vuelva inestable.</li> <li><b>Flexibilidad en el Manejo de Interrupciones:</b> La prioridad permite adaptar el comportamiento del sistema según las necesidades del momento, garantizando que siempre se atiendan las tareas críticas a tiempo.</li> 
                </ul>
                <br>
                
                <h3>Técnicas para Determinar el Dispositivo que provocó la interrupción</h3>
                <ul class="lista">
                    <li><b>Múltiples lineas de Interrupciones:</b> Cada dispositivo tiene su propia línea de interrupción hacia el procesador, permitiendo identificar rápidamente el origen del evento.</li>
                    <li><b>Consulta de software (polling):</b> La CPU revisa constantemente cada dispositivo para verificar si ocurrió una interrupción, aunque esto consume más tiempo y recursos.</li>
                    <li><b>Consulta de hardware:</b> Se emplea un controlador de interrupciones que consulta automáticamente qué dispositivo generó la señal y notifica al procesador.</li>
                    <li><b>Arbitraje de Bus:</b> Los dispositivos compiten por el control del bus; un mecanismo de prioridad decide cuál tiene permiso para enviar la interrupción primero.</li>
                </ul>
                <br>
                
                <h3>Propiedades de las Interrupciones</h3>
                <ul class="lista">
                    <li><b>Asincronía:</b> Las interrupciones pueden ocurrir en cualquier momento, ya que no dependen del flujo del programa en ejecución.</li>
                    <li><b>Prioridad:</b> Las interrupciones tienen diferentes niveles de prioridad para garantizar que los eventos más críticos se atiendan primero.</li>
                    <li><b>Anidamiento:</b> Una interrupción puede ser interrumpida por otra de mayor prioridad, lo que permite una gestión eficiente de eventos urgentes.</li>
                    <li><b>Restauración del estado:</b> La CPU guarda y recupera el estado del programa interrumpido para continuar la ejecución sin pérdida de datos.</li>
                    <li><b>Eficiencia:</b> Las interrupciones permiten que la CPU no desperdicie tiempo verificando constantemente los dispositivos; sólo actúa cuando es necesario.</li>
                    <li><b>Manejo de errores:</b> Las interrupciones permiten detectar y gestionar errores en operaciones de E/S o hardware, mejorando la robustez del sistema.</li>
                </ul>
                
                <button onclick="scrollToTop('interrupciones')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** MICROCONTROLADORES -->
            <section id="microcontroladores" class="contenido">
                <h2 class="titulo2">MICROCONTROLADORES</h2>
                <h3>Microcontroladores</h3>
                <p>
                    Un <b>microcontrolador</b> es un circuito integrado programable que ejecuta ordenes grabadas en su memoria.  Es un <b>sistema cerrado</b> que incluye CPU, memoria y periféricos en un solo chip. <br>
                    Está diseñado para <b>aplicaciones específicas</b> y control de aplicaciones. Los microcontroladores son comunes en sistemas embebidos, como electrodomésticos, automóviles, dispositivos médicos y sistemas de automatización industrial.
                </p>
                <div class="contenedor-imagen-tabla">
                    <img src="images/adc-microcontrolador.jpg" width="300px" alt="Microcontrolador" title="Microcontrolador">
                    <img src="images/adc-microprocesador.jpeg" width="300px" alt="Microprocesador" title="Microprocesador">
                </div>
                <br>

                <h3>Microprocesadores</h3>
                <p>
                    Un <b>microprocesador</b> es un circuito integrado que <b>contiene la CPU de una computadora</b>. Es un <b>sistema abierto</b> que requiere <b>componentes</b> externos, como memoria y periféricos para <b>poder funcionar</b>. <br>
                    Los microprocesadores se utilizan en una amplia gama de dispositivos, incluido computadoras personales, servidores, dispositivos móviles y sistemas embebidos de alto rendimiento.
                </p>
                <div class="contenedor-imagen-tabla">
                    <table>
                        <tr>
                            <th style="background-color: rgb(31, 34, 34); ;"> </th>
                            <th>MICRO CONTROLADOR</th>
                            <th>MICRO PROCESADOR</th>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Tipo de sistemas</td>
                            <td>Cerrado</td>
                            <td>Abierto</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Buses</td>
                            <td>Inaccesibles desde el exterior</td>
                            <td>Accesibles desde el exterior</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Memoria</td>
                            <td>Interna, incluye RAM, ROM y almacenamiento</td>
                            <td>Externa, necesita componenetes adicionales</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Flexibilidad</td>
                            <td>Limitada a aplicaciones específicas y tareas predefinidas</td>
                            <td>Alta, se puede utilizar una amplia variedad de aplicaciones</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Complejidad del sistema</td>
                            <td>Menor, integrado en un solo chip</td>
                            <td>Mayor, requiere componentes externos como memoria y periféricos</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Costo</td>
                            <td>Generalmente más barato, todo en un solo chip</td>
                            <td>Generlamente más caro, debido a la necesidad de componentes adicionales</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Ejemplos de uso</td>
                            <td>Electrodomésticos, automóviles, sistemas de automatización</td>
                            <td>Computadoras, servidores, dispositivos móviles</td>
                        </tr>
                        <tr>
                            <td class="fila-descripcion">Capacidad de procesamiento</td>
                            <td>Menos potentes, optimizados para eficiencia y tareas específicas</td>
                            <td>Generalemtne más potentes y rápidos</td>
                        </tr>
                    </table>
                </div>
                <br>

                <h2 class="titulo2">ARQUITECTURAS</h2>
                <div class="contenedor-imagen-tabla">
                    <img src="images/adc-arquitecturas.png" width="800px" alt="arquitecturas" title="Arquitecturas">
                </div>
                <br>
                <h3>Arquitectura Harvard</h3>
                <p>
                    La arquitecura Harvard utiliza <b>dos memorias separadas para instrucciones y datos</b>, permitiendo acceso simultáneo a ambas, lo cual puede incrementar el rendimiento. <br>
                    Esta arquitectura es común en <b>microcontroladores</b>, especialmente en aplicaciones donde se requiere un rendimiento elevado y un control preciso, como en sistemas embebidos y dispositivos de tiempo real. <br><br>
                    En este diseño, la CPU está conectada a dos memorias independientes y con buses diferentes: una para las instrucciones y otra para los datos. Esta configuración permite el <b>paralelismo</b>, ya que se puede acceder a los datos e instrucciones de forma independiente y simultánea.<br>
                    Las memorias no necesariamente deben compartir características, por lo que pueden tener distinta longitud de datos e instrucciones, permitiendo una optimización del uso de la memoria en general.<br>
                    El tiempo de acceso a las instrucciones y a los datos puede superponerse, aumetando la velocidad de procesamiento en cada operación.<br><br>
                    Además, facilita la realización de <b>pipeline</b>, una técnica de segmentación que permite al procesador ejecutar una instrucción mientras busca el código de la siguiente.<br> 
                    Las instrucciones y los datos se almacenan en caches separadas para mejorar el rendimiento. <br>
                    Sin embargo, esta arquitectura tiene <u>desventajas</u>. Divide la cantidad de caché entre instrucciones y datos, lo que solo es beneficioso si la frecuencia de lectura de ambos es similar.<br> 
                    También requiere dos buses separados, lo que aumenta la complejidad y el costo de fabricación.
                </p>
                <br>

                <h3>Arquitectura Von Neumann</h3>
                <p>
                    La arquitectura Von Neumann utiliza una sola memoria para almacenar tanto las instrucciones como los datos.<br>
                    Esta arquitectura describe a la computadora con <b>cuatros secciones principales: </b>
                    <ol>
                        <li>Memoria principal</li>
                        <li>Dispositivos de entrada-salida</li>
                        <li>Unidad Centra de Procesamiento (CPU)</li>
                        <li>Las interconexiones o buses entre todos los bloques funcionales del sistema</li>
                    </ol>
                    <br>

                    Es común en <b>microprocesadores</b> y procesadores de señal digital, debido a su simplicidad y flexibilidad, lo que facilita el diseño en sistemas de propósito general, como los que se encuentran en las computadoras personales. <br><br>
                    En este diseño, la CPU está conectada a una <b>memoria principal única</b> (generalmente RAM), donde se guardan tanto las instrucciones del programa como los datos, lo cual hace que el procesamiento sea eficiente debido a que todo está ubicado en un solo lugar. Esto elimina la necesidad de buses separados y permite una búsqueda más directa y eficiente. <br>
                    Sin embargo, <b>requiere un mecanismo para distinguri entre datos e instrucciones, ya que se almacenan en el mismo formato.</b><br><br>
                    La arquitectura de Von Neumann es relativamente fácil de diseñar y eficiente en el uso de la memoria, ya que no desperdicia espacio de almacenamiento al ser usada por ambos tipos de información. Una particularidad de esta arquitectura es que la <b>conexión se realiza mediante un único bus.</b> El tamaño de las instrucciones es fijado por el ancho del bus; por ejemplo, un microprocesador de 8 bits con un bus de 8 bits tendrá que manejar datos e instrucciones en unidades de 8 bits (bytes). Si se necesita acceder a una instrucción que excede el ancho de bus, se deberán realizar múltiples accesos a la memoria.<br><br>
                    Tener un único bús hace más lenta la respuesta del microprocesador, ya que no puede buscar en memoria una nueva instrucción mientras está transfiriendo datos de la instrucción anterior.<br>
                    Ademas, <b>requiere de dos ciclos de reloj para leer la memoria, uno para las instrucciones y otro para los datos.</b><br>
                    El cuello de botella de Von Neumann se puede mejorar de varias maneras, como con el uso de memoria caché entre la CPU y la memoria princial, o con vías independientes para instrucciones y datos (arquitectura Harvard modificada), para reducir el acceso a memoria.
                </p>
                <br>

                <h2 class="titulo2">INSTRUCCIONES (CISC - RISC)</h2>
                <h3>Conjunto de instrucciones</h3>
                <p>
                    Los <b>microprocesadores</b> suelen ser <b>CISC (Complex Instruction Set Computing)</b>, estos tienen un conjunto de instrucciones grande y complejo, diseñado para realizar tareas complejas en pocas líneas de código. (Secuenciadores microprogramados)
                    <ul class="lista">
                        <li>
                            <b>Características</b>
                            <ul class="lista" style="list-style: circle;">
                                <li><b>Conjunto de instrucciones grandes:</b> Hay muchas instrucciones disponibles, lo que permite realizar tareas complejas en una sola línea de código.</li>
                                <li><b>Complejidad:</b> Hay muchas instrucciones disponibles, lo que permite realizar tareas complejas en una sola línea de código.</li>
                                <li><b>Eficiencia en codificación:</b> Los programadores pueden escribir programas más cortos y complejos, lo que puede reducir el tiempo de desarrollo.</li>
                                <li><b>Variedad de modos de direccionamiento:</b> Permite diferentes formas de acceder a la memoria, lo que añade flexibilidad.</li>
                                <li><b>Mayor consumo de energia:</b> Por lo general, CISC consume más energía debido a su complejidad.</li>
                            </ul>
                        </li>
                        <li>
                            <b>Aplicaciones:</b> Utilizados en computadoras personales, servidores y estaciones de trabajo donde la flexibilidad y la capacidad de realizar tareas complejas son cruciales.
                        </li>
                    </ul>
                    <br>

                    Los <b>microcontroladores</b> suelen ser <b>RISC (Reduced Instruction Set Computing)</b>, estos tienen un conjunto de instrucciones más pequeño y simplificado, optimizado para realizar operaciones básicas de manera rápida y eficiente. Esto es beneficioso para aplciaciones embebidas que requieren alta eficiencia y bajo consumo de energía.
                    <ul class="lista">
                        <li>
                            <b>Características</b>
                            <ul class="lista" style="list-style: circle;">
                                <li><b>Conjunto de instrucciones pequeño:</b> Hay menos instrucciones, lo que simplifica el diseño del procesador.</li>
                                <li><b>Simplicidad:</b> La arquitectura es más sencilla, lo que facilita su implementación.</li>
                                <li><b>Optimización para operaciones básicas:</b> Está diseñado para ejecutar instrucciones simples rápidamente.</li>
                                <li><b>Eficiencia en la ejecución:</b> Las instrucciones se ejecutan de manera más eficiente, gracias a la simplicidad del conjunto.</li>
                                <li><b>Pipeline:</b> Permite que diferentes etapas de ejecución de instrucciones se realicen simultáneamente, aumentando la eficiencia.</li>
                            </ul>
                        </li>

                        <li>
                            <b>Aplicaciones:</b> Ideal para aplicaciones embebidas que requieren alta eficiencia y bajo consumode energia, como electrodomésticos, automóviles, dispositivos médicos y sistemas de automatización industrial.
                        </li>                        
                    </ul>
                    <br>

                    Cabe destacar que el análisis de instrucción no es necesario en <b>RISC</b> porque no hay microprograma, RISC trabaja con <b>secuenciadores cableados.</b><br>
                    En cuanto al cálculo de la dirección del operando, las <b>transferencia se hacen entre registros</b>, y la búsqueda del operando no es necesaria ya que el <b>operando está en registros de acceso</b> muy rápido.<br>
                    Además, cada instruccion en RISC toma solo <b>un solo ciclo de reloj</b>, lo que constribuye a su alta eficiencia.
                    <br>

                    <div class="contenedor-imagen-tabla">
                        <table>
                            <tr>
                                <th> Características</th>
                                <th>RISC</th>
                                <th>CISC</th>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Simplicidad de instrucciones</b></td>
                                <td>Instrucciones simples, típicamente <b>1 ciclo de ejecución</b></td>
                                <td>Instrucciones complejas, pueden tomar <b>múltiples ciclos de ejecución</b></td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Acceso a Memoria</b></td>
                                <td>Referencias a memoria solo con instrucciones LOAD/STORE</td>
                                <td>Cualquier instrucción puede referenciar a la memoria.</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Pipeline</b></td>
                                <td>Más eficaz, con menos etapas</td>
                                <td>Menos eficaz, con más etapas</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Ejecución de instrucciones</b></td>
                                <td>Ejecutadas directamente por el <b>hardware</b></td>
                                <td>INterpretadas por un <b>microprograma</b></td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Formato de instrucciones</b></td>
                                <td>Formato <b>fijo</b> de instrucciones</td>
                                <td>Formato <b>variable</b> de instrucciones</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Cantidad de ejecuciones</b></td>
                                <td>Poca instruccioens y modos de instrucción</td>
                                <td>Muchas instrucciones y modos</td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Complejidad del Sistema</b></td>
                                <td>La complejidad se encuentra en el <b>compilador</b></td>
                                <td>Complejidad en el <b>microprograma</b></td>
                            </tr>
                            <tr>
                                <td class="fila-descripcion"><b>Registro</b></td>
                                <td>Conjunto <b>múltiple</b> de registros</td>
                                <td>Conjunto <b>único</b> de registros</td>
                            </tr>
                        </table>
                    </div>
                    <br>

                    En conclusión, se puede decir que las máquinas RISC completan todas sus instrucciones en un solo ciclo de reloj, es por eso que es más rápida que las máquinas CISC, y en RISC contamos con un gran manejo de registros. Sin embargo, para efectuar una operación de mayor complejidad (como multipicaciones o divisiones) necesitamos más instrucciones como en CISC.<br>
                    Por eso un usuario debe definirse a favor o en contra de una arquitectura en función de la aplicación que desea realizar.
                </p>
                <br>

                <h2 class="titulo2"> PIPELINE EN MICROCONTROLADORES</h2> 
                <p>
                    El <b>pipeline</b> en los <b>microcontroladores es una técnica segmentada</b> utilizada para aumentar la eficiencia y la velocidad de procesamiento al dividir la <b>ejecución de una tarea en múltiples etapas independientes.</b><br>
                    Estas etapas pueden ejecutarse simultáneamente en diferentes partes del hardware del microcontrolador. 
                    <br>
                    
                    La tarea de ejecutar una instrucción se divide en varias etapas como:
                    <ul class="lista">
                        <li>la búsqueda de la instrucción (fetch), </li>
                        <li>la decodifcación (decode), </li>
                        <li>la ejecución (execute), </li>
                        <li>la memoria (memory), y </li>
                        <li>la escritura del resultado (write-back)</li>
                    </ul> 
                    <br>

                    Cada una de estas etapas puede trabajar en diferentes instruciones al mismo tiempo.<br>
                    <div class="cuadro">
                        Por ejemplo, mientras una instrucción está siendo decodificada, otra puede estar siendo buscada y otra puede estar siendo ejecutada. Sin embargo, las <u>dependencias</u> de datos y otros problemas pueden causar ralentizaciones, por lo que se requieren diversas estrategias para mitigar estos problemas y mantener el flujo de instrucciones lo más fluido posible.
                    </div>
                    <br><br>

                    <h3>Estrategias para mitigar problemas en el pipeline</h3>
                    <h4>Incluyen:</h4>
                    <ul class="lista">
                        <li>Interbloque (Stalling)</li>
                        <li>Reordenamiento de instrucciones</li>
                        <li>Bypassing / Forwarding</li>
                        <li>Predicción de saltos</li>
                    </ul>
                    <br>

                    <h4>Ventajas</h4>
                    <ul class="lista">
                        <li>Mayor rendimiento</li>
                        <li>Eficiencia</li>
                    </ul>
                    <br>

                    <h4>Desventajas</h4>
                    <ul class="lista">
                        <li>Interbloqueos</li>
                        <li>Complejidad de Control</li>
                    </ul>
                </p>
                <br>

                <h3>Comparación con Microprocesadores</h3>
                <p>
                    Los <b>microprocesadores</b>, diseñados para tareas más complejas y de alto rendimiento, implementan pipeline de manera más agresiva y sofisticada.<br>
                    Tienen más recursos disponibles y pueden permitirse un pipeline más profundo y complejo, lo cual mejora significativamente el rendimiento costa de mayor consumo de energía.<br><br>
                    Por otro lado, los <b>microcontroladores</b> están diseñados para aplicaciones específicas y de menor consumo energético, por lo que su implementación de pipeline tiende a ser más sencilla y menos profunda.
                </p>
                <br>

                <h3>Comparación con Procesador sin Pipeline</h3>
                <p>
                    <ul>
                        <li><b>Sin Pipeline: </b> Cada instrucción debe completarse antes de que la siguiente comience, lo que puede resultar en una ejecución más lenta.</li>
                        <li><b>Ventaja de Sin Pipeline: </b> Diseño más sencillo y menor complejidad en la unidad de control.</li>
                    </ul>
                </p>
                <br><br>

                <h2 class="titulo2">FORMATO DE INSTRUCCIONES ORTOGONAL</h2>
                <p>
                    El <b>formato de instrucciones ortogonal</b> es un diseño de conjunto de instrucciones en el que <b>cualquier operación puede ser realizada con cualquier registro o modo de direccionamiento disponible.</b> 
                    <br>Esto proporciona una gran flexibilidad y simplicidad en la programación, ya que permite utilizar <b>cualquier combinación de registros y modos de direccionamiento para cualquier instrucción.</b><br>
                    Sin embargo, este formato puede resultar en instrucciones de mayor tamaño, lo que aumenta la complejidad de decodificación, y también incrementa la complejidad del hardware al requerir soporte  para todas las combinaciones posibles.
                    <br><br>

                    <h4>Ventajas</h4>
                    <ul class="lista">
                        <li>Flexibilidad: Facilita la programación al permitir una mayor flexibilidad en el uso de registros y modos de direccionamiento.</li>
                        <li>Simplicidad: Simplifica el diseño del compilador y el código ensamblador</li>
                    </ul>
                    <br><br>

                    <h4>Desventajas</h4>
                    <ul class="lista">
                        <li>Tamaño de instrucciones: Puede resultar en isntrucciones de mayor tamaño, lo que aumenta la complejidad de decodificación.</li>
                        <li>Costo: Aumenta la complejidad de hardware, ya que se necesita soporte para todas las combinaciones posibles de registros y modos de direccionamiento.</li>
                    </ul>
                </p>
                <br><br>

                <h3>Amplio banco de registros:</h3>
                <p>
                    Un <b>amplio banco de registros</b> se refiere a disponer de una <b>gran cantidad de registros</b> accesibles por el procesador de operaciones rápidas. ESto reduce la necesidad de acceder a la memoria princial, acelerando el procesamiento y permitiendo que más variables temporales y datos intermedio se almacenan en registros, optimizando la eficiencia del código.<br>
                    Sin embargo, tener más registros puede complicar la gestión de contexto durante interrupciones o cambios de tarea, y aumentar el costo y la complejidad del hardware en comparación con un <b>banco de registro limitado</b>, que requiere más acceso a memoria y puede ralentizar el procesamiento, aunque <b>simplifica el diseño y reduce los costos</b>
                    <br><br>

                    <h4>Ventajas</h4>
                    <ul class="lista">
                        <li>Eficiencia: Reduce la necesidad de acceder a la memoria principal, lo que acelera el procesamiento.</li>
                        <li>Optimización de Código: Permite que más variables temporales y datos intermedios se almacenan en registros, mejorando la eficiencia del código.</li>
                    </ul>
                    <br><br>

                    <h4>Desventajas</h4>
                    <ul class="lista">
                        <li>Complejidad de manejo: Un mayor número de registros puede complicar la gestión de contexto durante interrupciones o cambios de tarea.</li>
                        <li>Costo de hardware: Más registros pueden aumentar el costo y la complejidad del hardware</li>
                    </ul>
                    <br><br>

                    <h4>Comparación de Regitro Limitado</h4>
                    <ul class="lista">
                        <li>Registros limitados: Menos registros requieren más accesos a memoria, lo que puede ralentizar el procesamiento.</li>
                        <li>Ventaja de registros limitados: Diseño más sencillo y menor costo de hardware.</li>
                    </ul>
                </p>

                <button onclick="scrollToTop('microcontroladores')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** PIPELINE -->
            <section id="pipeline" class="contenido">
                <h2>Pipeline</h2>
                <p>Conceptos relacionados con el pipeline y su funcionamiento en los procesadores.</p>
                <button onclick="scrollToTop('pipeline')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** ENTRADA - SALIDA -->
            <section id="entrada-salida" class="contenido">
                <h2 class="titulo2">Entrada - Salida</h2>
                
                <button onclick="scrollToTop('entrada-salida')">▲</button>
            </section>

            <!-- ********************************************************************************************************** PARALELISMO -->
            <section id="paralelismo" class="contenido">
                <h2>Paralelismo</h2>
                <p>PARALELISMO</p>
                <button onclick="scrollToTop('paralelismo')">▲</button>
            </section>

            <!-- ********************************************************************************************************** SECUENCIADORES -->
            <section id="secuenciadores" class="contenido">
                <h2>SECUENCIADORES</h2>
                <p>Descripción detallada sobre los sistemas de SECUENCIADORES</p>
                <button onclick="scrollToTop('secuenciadores')">▲</button>
            </section>

            

            <!-- ********************************************************************************************************** MEMORIA CACHE -->
            <section id="memoria-cache" class="contenido">
                <h2>Memoria Caché</h2>
                <p>Funcionamiento de la memoria caché y su importancia en la arquitectura de computadoras.</p>
                <button onclick="scrollToTop('memoria-cache')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** COHERENCIA CACHE -->
            <section id="coherencia-cache" class="contenido">
                <h2>Coherencia Caché</h2>
                <p>Funcionamiento de la memoria caché y su importancia en la arquitectura de computadoras.</p>
                <button onclick="scrollToTop('coherencia-cache')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <!-- ********************************************************************************************************** EXAMENES -->
            <section id="examenes" class="contenido">
                <h2>Exámenes</h2>
                <p>
                    Listado de los exámenes recolectados.
                </p>
                <br>

                <!-- MICROCONTROLADORES -->
                <h2 class="titulo2">MICROCONTROLADORES</h2>
                <b class="negrita-color">AÑO 2023</b>
                <ul class="lista">
                    <li>¿Qué son y que los diferencia de los microprocesadores?</li>
                    <li>¿Qué tipo de Arquitectura tienen?</li>
                    <li>Son CISC o RISC? Detalle porqué y que caracteristicas incluye.</li>
                    <li>¿Cómo es el pipeline en los microcontroladores?</li>
                </ul>
                <br>
                
                <b class="negrita-color">AÑO 2024</b>
                <ul class="lista">
                    <li>Describa las principales características de los microcontroladores.</li>
                </ul>
                <br>

                <!-- INTERRUPCIONES-->
                <h2 class="titulo2">INTERRUPCIONES</h2>
                <b class="negrita-color">AÑO 2023 | 2024</b>
                <ul class="lista">
                    <li>Describa el funcionamiento general y su utilidad.</li>
                    <li>Describa en detalle cómo es el mecnaismo de interrupciones, incluyendo el uso de la pila.</li>
                    <li>Interrupciones anidadas y secuenciales.</li>
                    <li>Propiedades.</li>
                    <li>Rutinas de Servicio (ISR), su localización y acceso a ellas.</li>
                </ul>
                <br>

                <!-- PIPELINE -->
                <h2 class="titulo2">PIPELINE</h2>
                <b class="negrita-color">AÑO 2023 | 2024</b>
                <ul class="lista">
                    <li>En que consiste y cual es el beneficio que brinda.</li>
                    <li>Que instrucciones generan problemas, por qué, y que soluciones utiliza.</li>
                    <li>Grafique un pipeline genérico de cinco etapas de una máquina CISC y describa la función de cada una de ellas.</li>
                    <li>Grafique un diagrama de tiempo indicando la ejecución de instrucciones en ese pipeline de 5 etapas.</li>
                </ul>
                <br>

                <!-- SECUENCIADORES -->
                <h2 class="titulo2">SECUENCIADORES</h2>
                <b class="negrita-color">AÑO 2023</b>
                <ul class="lista">
                    <li>¿Para qué arquitecturas son adecuados los secuenciadores micrprogramados?</li>
                    <li>¿Para qué arquitecturas son adecuados los secuenciadores cableados?</li>
                </ul>
                <b class="negrita-color">AÑO 2024</b>
                <ul class="lista">
                    <li>Describa los secuenciadores de tipo cableados en detalles.</li>
                    <li>Describa los secuenciadores microprogramados.</li>
                    <li>Modelo de Wilkes.</li>
                    <li>Direccionamiento implícito y explícito.</li>
                    <li>Microprogramación vertical y horizontal.</li>
                    <li>Microinstrucciones por micro orden o por campo.</li>
                </ul>

                <!-- PARALELISMO -->
                <h2 class="titulo2">PARALELISMO</h2>
                <b class="negrita-color">AÑO 2023 | 2024</b>
                <ul class="lista">
                    <li>Describa la clasificación de Flynn</li>
                    <li>Respecto a MIMD, describa en detalle multicomputadores y multiprocesadores</li>
                    <li>Caracteristicas</li>
                    <li>Diferencias</li>
                </ul>

                <!-- MEMORIA CACHÉ -->
                <h2 class="titulo2">MEMORIA CACHE</h2>
                <b class="negrita-color">AÑO 2024</b>
                <ul class="lista">
                    <li>Describa el objetivo de las memorias caché y como se implementan.</li>
                    <li>Describa su funcionamiento, funciones de mapeo y algoritmos de reemplazo.</li>
                </ul>








                <button onclick="scrollToTop('examenes')">▲</button>
                <!--<button onclick="goBack()">Volver Atrás</button>-->
            </section>

            <div id="content-display" class="contenido">Selecciona una materia para ver su contenido aquí.</div>
        </main>

    </div>

    <script src="scriptM.js"></script>
</body>
</html>
